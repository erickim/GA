x[[1]]$variables[1]
split <- sample(N, 1)
c(x[[1]]$variables[1:split], x[[2]]$variables[split+1:N]_
c(x[[1]]$variables[1:split], x[[2]]$variables[split+1:N])
c(x[[1]]$variables[1:split], x[[2]]$variables[(split+1):N])
length(c(x[[1]]$variables[1:split], x[[2]]$variables[(split+1):N]))
crossover <- function(type, parent1, parent2) {
#' Genetic Algorithms Crossover Operation
#'
#' Arguments:
#' @param type The type of crossover, either
#' @param parent1 The \code{variables} output from a parent.
#' @param parent2 The \code{variables} output from another parent.
#'
#' @return A list of vectors of the children to return.
N <- length(parent1)
split <- sample(N, 1)
child1 <- c(parent1[1:split], parent2[(split+1):N])
child2 <- c(parent2[1:split], parent1[(split+1):N])
return(list(child1 = child1, child2 = child2))
}
?crossover
source("./R/utils.R")
set.seed(1)
Y <- rnorm(100)
X <- as.data.frame(matrix(rnorm(100*26), nrow = 100))
names(X) <- letters
P <- ncol(X)*2
set.seed(1)
Y <- rnorm(100)
X <- as.data.frame(matrix(rnorm(100*26), nrow = 100))
names(X) <- letters
P <- ncol(X)*2
source("./R/utils.R")
crossover12 <- crossover("", init_pop[[1]], init_pop[[2]])
init_pop <- initialize(Y, X, P)
crossover12 <- crossover("", init_pop[[1]], init_pop[[2]])
crossover12[[1]]
crossover12 <- crossover("", init_pop[[1]]$variables, init_pop[[2]]$variables)
crossover12[[1]]
crossover12[[2]]
init_pop[[1]]$variables
init_pop[[2]]$variables
?sample
x = NA
x <= 2
TRUE | FALSE
FALSE | FALSE
?order
order(sample(10, 3))
sample(10, 3)
sort(sample(10, 3))
sort(sample(10, 3))
sort(sample(10, 3))
x <- list()
x[[1]]  = 2
x
x[[2]] = 3
x
rm(x)
parent1 = init_pop[[1]]$variables
parent2 = init_pop[[2]]$variables
num_splits = 3
splits <- sort(sample(N, num_splits))
parent1Split <- list()
parent2Split <- list()
parent1Split[[1]] <- parent1[1:splits[i]]
N <- length(parent1)
splits <- sort(sample(N, num_splits))
parent1Split <- list()
parent2Split <- list()
parent1Split[[1]] <- parent1[1:splits[i]]
parent1Split[[1]] <- parent1[1:splits[1]]
parent2Split[[1]] <- parent1[1:splits[1]]
for (i in 2:length(splits)) {
parent1Split[[i]] <- parent1[splits[i-1]+1:splits[i]]
parent2Split[[i]] <- parent2[splits[i-1]+1:splits[i]]
}
parent1Split
parent1Split <- list()
parent2Split <- list()
parent1Split[[1]] <- parent1[1:splits[1]]
parent2Split[[1]] <- parent1[1:splits[1]]
for (i in 2:length(splits)) {
parent1Split[[i]] <- parent1[(splits[i-1]+1):splits[i]]
parent2Split[[i]] <- parent2[(splits[i-1]+1):splits[i]]
}
parent1Split
parent2Split
help("initialize")
help(initialize)
?initialize
help(crossocer)
help(crossover)
?crossover
10 % 2
10 %% 2
child1 <- c()
child2 <- c()
for (i in 1:length(splits)) {
if (i %% 2 == 1) {
child1 <- c(child1, parent1Split[[i]])
child2 <- c(child2, parent2Split[[i]])
} else {
child1 <- c(child1, parent2Split[[i]])
child2 <- c(child2, parent1Split[[i]])
}
}
child1
child2
parent1Split[[1]]; parent2Split[[2]]; parent1Split[[3]]
parent2Split[[1]]; parent1Split[[2]]; parent2Split[[3]]
parent1Split <- list()
parent2Split <- list()
parent1Split[[1]] <- parent1[1:splits[1]]
parent2Split[[1]] <- parent2[1:splits[1]]
for (i in 2:length(splits)) {
parent1Split[[i]] <- parent1[(splits[i-1]+1):splits[i]]
parent2Split[[i]] <- parent2[(splits[i-1]+1):splits[i]]
}
child1 <- c()
child2 <- c()
for (i in 1:length(splits)) {
if (i %% 2 == 1) {
child1 <- c(child1, parent1Split[[i]])
child2 <- c(child2, parent2Split[[i]])
} else {
child1 <- c(child1, parent2Split[[i]])
child2 <- c(child2, parent1Split[[i]])
}
}
child1
child2
parent1Split[[1]]; parent2Split[[2]]; parent1Split[[3]]
parent2Split[[1]]; parent1Split[[2]]; parent2Split[[3]]
source("./R/utils.R")
set.seed(1)
Y <- rnorm(100)
X <- as.data.frame(matrix(rnorm(100*26), nrow = 100))
names(X) <- letters
P <- ncol(X)*2
init_pop <- initialize(Y, X, P)
crossoverSingle <- crossover(init_pop[[1]]$variables,
init_pop[[2]]$variables,
"single")
crossoverMultiple <- crossover(init_pop[[1]]$variables,
init_pop[[2]]$variables,
"multiple",
3)
source("./R/utils.R")
set.seed(1)
Y <- rnorm(100)
X <- as.data.frame(matrix(rnorm(100*26), nrow = 100))
names(X) <- letters
P <- ncol(X)*2
init_pop <- initialize(Y, X, P)
crossoverSingle <- crossover(init_pop[[1]]$variables,
init_pop[[2]]$variables,
"single")
crossoverMultiple <- crossover(init_pop[[1]]$variables,
init_pop[[2]]$variables,
"multiple",
3)
crossoverSingle
crossoverMultiple
child1
source("./R/utils.R")
set.seed(1)
Y <- rnorm(100)
X <- as.data.frame(matrix(rnorm(100*26), nrow = 100))
names(X) <- letters
P <- ncol(X)*2
init_pop <- initialize(Y, X, P)
crossoverSingle <- crossover(init_pop[[1]]$variables,
init_pop[[2]]$variables,
"single")
crossoverMultiple <- crossover(init_pop[[1]]$variables,
init_pop[[2]]$variables,
"multiple",
3)
crossoverMultiple
source("./R/utils.R")
source("./R/utils.R")
### EXAMPLES ###
set.seed(1)
Y <- rnorm(100)
X <- as.data.frame(matrix(rnorm(100*26), nrow = 100))
names(X) <- letters
P <- ncol(X)*2
init_pop <- initialize(Y, X, P)
crossoverSingle <- crossover(init_pop[[1]]$variables,
init_pop[[2]]$variables,
"single")
# $child1
# [1] 0 1 1 1 1 1 0 0 0 1 0 1 1 0 1 0 0 0 1 0 0 1 1 1 0 1
# $child2
# [1] 1 1 1 0 1 0 0 1 1 1 0 0 1 0 1 1 1 1 0 1 0 0 0 1 1 0
crossoverMultiple <- crossover(init_pop[[1]]$variables,
init_pop[[2]]$variables,
"multiple",
3)
#xaic <- lapply(x, AIC)
crossoverMultiple
crossoverMultiple <- crossover(init_pop[[1]]$variables,
init_pop[[2]]$variables,
"multiple",
3)
length(crossoverMultiple$child1)
N <- length(parent1)
splits <- sort(sample(N, num_splits))
parent1Split <- list()
parent2Split <- list()
parent1Split[[1]] <- parent1[1:splits[1]]
parent2Split[[1]] <- parent2[1:splits[1]]
for (i in 2:num_splits) {
parent1Split[[i]] <- parent1[(splits[i - 1] + 1):splits[i]]
parent2Split[[i]] <- parent2[(splits[i - 1] + 1):splits[i]]
}
parent1Split[[num_splits + 1]] <- parent1[(splits[num_splits] + 1):N]
parent2Split[[num_splits + 1]] <- parent2[(splits[num_splits] + 1):N]
parent1Split
parent2Split
child1 <- c()
child2 <- c()
for (i in 1:num_splits + 1) {
if (i %% 2 == 1) {
child1 <- c(child1, parent1Split[[i]])
child2 <- c(child2, parent2Split[[i]])
} else {
child1 <- c(child1, parent2Split[[i]])
child2 <- c(child2, parent1Split[[i]])
}
}
child1
length(child1)
child1 <- c()
child2 <- c()
for (i in 1:(num_splits + 1)) {
if (i %% 2 == 1) {
child1 <- c(child1, parent1Split[[i]])
child2 <- c(child2, parent2Split[[i]])
} else {
child1 <- c(child1, parent2Split[[i]])
child2 <- c(child2, parent1Split[[i]])
}
}
length(child1)
crossoverMultiple <- crossover(init_pop[[1]]$variables,
init_pop[[2]]$variables,
"multiple",
3)
crossoverMultiple
source("./R/utils.R")
source("./R/utils.R")
### EXAMPLES ###
set.seed(1)
Y <- rnorm(100)
X <- as.data.frame(matrix(rnorm(100*26), nrow = 100))
names(X) <- letters
P <- ncol(X)*2
init_pop <- initialize(Y, X, P)
crossoverSingle <- crossover(init_pop[[1]]$variables,
init_pop[[2]]$variables,
"single")
# $child1
# [1] 0 1 1 1 1 1 0 0 0 1 0 1 1 0 1 0 0 0 1 0 0 1 1 1 0 1
# $child2
# [1] 1 1 1 0 1 0 0 1 1 1 0 0 1 0 1 1 1 1 0 1 0 0 0 1 1 0
crossoverMultiple <- crossover(init_pop[[1]]$variables,
init_pop[[2]]$variables,
"multiple",
3)
#$child1
#[1] 1 1 0 1 0 0 1 1 1 0 1 1 0 1 1 1 0 1 0 0 1 1 1 0 1
#$child2
#[1] 1 1 1 1 1 0 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 1 0
# ignore below
#xaic <- lapply(x, AIC)
crossoverMultiple
crossoverMultiple$child1 %>% length
library(tidyverse)
crossoverMultiple$child1 %>% length
Y <- rnorm(100)
X <- as.data.frame(matrix(rnorm(100*1000), nrow = 100))
?glm
rbinom(1, .05)
rbinom(1, 1, .05)
rbinom(1, 1, .05)
rbinom(1, 1, .05)
rbinom(1, 1, .05)
rbinom(1, 1, .05)
rbinom(1, 1, .05)
rbinom(1, 1, .05)
rbinom(1, 1, .05)
rbinom(1, 1, .05)
sample(10, 1)
(2*1 + 1) %%2
(2*0 + 1) %% 2
(*1 + 1) %% 2
(1 + 1) %% 2
(0 + 1) %% 2
source("./R/utils.R")
source("./R/utils.R")
crossoverSingleMutation <- mutate(rate = .05,
offspring = crossoverSingle$child1)
source("./R/utils.R")
crossoverSingleMutation <- mutate(rate = .05,
offspring = crossoverSingle$child1)
crossoverSingleMutation
source("./R/utils.R")
set.seed(1)
Y <- rnorm(100)
X <- as.data.frame(matrix(rnorm(100*26), nrow = 100))
names(X) <- letters
P <- ncol(X)*2
init_pop <- initialize(Y, X, P)
crossoverSingle <- crossover(init_pop[[1]]$variables,
init_pop[[2]]$variables,
"single")
crossoverSingle
crossoverMultiple <- crossover(init_pop[[1]]$variables,
init_pop[[2]]$variables,
"multiple",
3)
crossoverMultiple <- crossover(init_pop[[1]]$variables,
init_pop[[2]]$variables,
"multiple",
3)
crossoverMultiple
crossoverSingleMutation <- mutate(rate = .05,
offspring = crossoverSingle$child1)
crossoverSingleMutation
?sample
sample(1:10, 1, (4:13)/sum(4:13))
sample(1:10, 1, prob = (4:13)/sum(4:13))
sample(1:10, 1, prob = (4:13)/sum(4:13))
sample(1:10, 1, prob = (4:13)/sum(4:13))
sample(1:10, 1, prob = (4:13)/sum(4:13))
sample(1:10, 1, prob = (4:13)/sum(4:13))
sample(1:10, 1, prob = (4:13)/sum(4:13))
x <- sample(1:10, 1, prob = (4:13)/sum(4:13))
1:10[-x]
x
(1:10)[-x]
init_pop[[1]]
lapply(init_pop, function(x) AIC(x$fit))
init_popAIC <- unlist(lapply(init_pop, function(x) AIC(x$fit)))
selection <- function(type, pop_fitness) {
#' Genetic Algorithms Selection Operation
#'
#' Arguments:
#' @param type The type of selection mechanism. Either \code{'oneprop'},
#' \code{'twoprop'}. See page 76 and 81 of G/H.
#' @param pop_fitness A vector of fitness values for the population
#'
#' @return The mutated or unmutated candidate.
if (!type %in% c('oneprop', 'twoprop', 'tournament')) {
message('Invalid selection mechanism, defaulting to `twoprop`.')
type <- 'twoprop'
}
N <- length(pop_fitness)
fitnessProbs <- pop_fitness / sum(pop_fitness)
if (type = 'oneprop') {
# pick first proportional to fitness
toSelect <- sample(1:N, 1, prob = fitnessProbs)
# pick second parent at random from the remaining
toSelect <- c(toSelect,
sample((1:N)[-toSelect]), 1)
} else if (type = 'twoprop') {
toSelect <- sample(1:N, 2, prob = fitnessProbs)
}
return(toSelect)
}
source("./R/utils.R")
set.seed(1)
Y <- rnorm(100)
X <- as.data.frame(matrix(rnorm(100*26), nrow = 100))
names(X) <- letters
P <- ncol(X)*2
initPop <- initialize(Y, X, P)
initPop <- initialize(Y, X, P)
initialize <- function(Y, X, P) {
#' Genetic Algorithms Initial Population Creation
#'
#' Arguments:
#' @param Y The response vector as passed into select.
#' @param X The feature matrix as passed into select.
#' @param P The size of the population as passed or determined in select.
#'
#' @return A list of the P generated candidate solutions
#' where each entry of the list contains
#' \itemize{
#' \item \code{variables}: The variables that were
#' selected for the population.
#' \item \code{fit}: The \code{lm} or \code{glm} object of the fit with the
#' above variables.
#' }
init_pop <- lapply(1:P, function(x) {
init_var <- rbinom(ncol(X), 1, .5)
init_sol <- lm(Y ~ ., data = as.matrix(X[,as.logical(init_var)]))
return(list(variables = init_var, fit = init_sol))
})
return(init_pop)
}
initPop <- initialize(Y, X, P)
initialize <- function(Y, X, P) {
#' Genetic Algorithms Initial Population Creation
#'
#' Arguments:
#' @param Y The response vector as passed into select.
#' @param X The feature matrix as passed into select.
#' @param P The size of the population as passed or determined in select.
#'
#' @return A list of the P generated candidate solutions
#' where each entry of the list contains
#' \itemize{
#' \item \code{variables}: The variables that were
#' selected for the population.
#' \item \code{fit}: The \code{lm} or \code{glm} object of the fit with the
#' above variables.
#' }
init_pop <- lapply(1:P, function(x) {
init_var <- rbinom(ncol(X), 1, .5)
init_sol <- lm(Y ~ ., data = X[,as.logical(init_var)])
return(list(variables = init_var, fit = init_sol))
})
return(init_pop)
}
initPop <- initialize(Y, X, P)
source("./R/utils.R")
set.seed(1)
source("./R/utils.R")
set.seed(1)
Y <- rnorm(100)
X <- as.data.frame(matrix(rnorm(100*26), nrow = 100))
names(X) <- letters
P <- ncol(X)*2
initPop <- initialize(Y, X, P)
crossoverSingle <- crossover(initPop[[1]]$variables,
initPop[[2]]$variables,
"single")
crossoverMultiple <- crossover(initPop[[1]]$variables,
initPop[[2]]$variables,
"multiple",
3)
crossoverSingleMutation <- mutate(rate = .05,
offspring = crossoverSingle$child1)
initPopAIC <- unlist(lapply(initPop, function(x) AIC(x$fit)))
selection('oneprop', initPopAIC)
sample(1:52, 1, initPopAIC/sum(initPopAIC))
sample(1:52, 1, prob = initPopAIC/sum(initPopAIC))
selection <- function(type, pop_fitness) {
#' Genetic Algorithms Selection Operation
#'
#' Arguments:
#' @param type The type of selection mechanism. Either \code{'oneprop'},
#' \code{'twoprop'}. See page 76 and 81 of G/H.
#' @param pop_fitness A vector of fitness values for the population
#'
#' @return The mutated or unmutated candidate.
if (!type %in% c('oneprop', 'twoprop', 'tournament')) {
message('Invalid selection mechanism, defaulting to `twoprop`.')
type <- 'twoprop'
}
N <- length(pop_fitness)
fitnessProbs <- pop_fitness / sum(pop_fitness)
if (type == 'oneprop') {
# pick first proportional to fitness
toSelect <- sample(1:N, 1, prob = fitnessProbs)
# pick second parent at random from the remaining
toSelect <- c(toSelect,
sample((1:N)[-toSelect], 1))
} else if (type == 'twoprop') {
toSelect <- sample(1:N, 2, prob = fitnessProbs)
}
return(toSelect)
}
source("./R/utils.R")
### EXAMPLES: DATA GENERATION ###
set.seed(1)
Y <- rnorm(100)
X <- as.data.frame(matrix(rnorm(100*26), nrow = 100))
names(X) <- letters
P <- ncol(X)*2
### EXAMPLES: INITIALIZE ###
initPop <- initialize(Y, X, P)
### EXAMPLES: CROSSOVER ###
crossoverSingle <- crossover(initPop[[1]]$variables,
initPop[[2]]$variables,
"single")
# $child1
# [1] 0 1 1 1 1 1 0 0 0 1 0 1 1 0 1 0 0 0 1 0 0 1 1 1 0 1
# $child2
# [1] 1 1 1 0 1 0 0 1 1 1 0 0 1 0 1 1 1 1 0 1 0 0 0 1 1 0
crossoverMultiple <- crossover(initPop[[1]]$variables,
initPop[[2]]$variables,
"multiple",
3)
# $child1
# [1] 0 1 1 0 1 0 0 1 1 1 0 1 1 0 1 1 1 0 1 0 0 1 1 1 0 1
# $child2
# [1] 1 1 1 1 1 1 0 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 1 0
### EXAMPLES: MUTATION ###
crossoverSingleMutation <- mutate(rate = .05,
offspring = crossoverSingle$child1)
# [1] 0 1 1 1 1 1 0 0 0 1 0 1 1 0 1 0 0 0 1 0 0 1 1 1 0 1
### EXAMPLES: SELECTION ###
initPopAIC <- unlist(lapply(initPop, function(x) AIC(x$fit)))
selection('oneprop', initPopAIC)
# ignore below
#xaic <- lapply(x, AIC)
selection('twoprop', initPopAIC)
